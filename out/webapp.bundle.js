/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/webapp.js":
/*!***********************!*\
  !*** ./src/webapp.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! idb */ \"./node_modules/idb/build/index.js\");\n\n\n\nclass LinksModel {\n    #localDB;\n    #databaseName;\n    #databaseVersion;\n\n    #onLinkbookDataChanged;\n    #onErrorHandle;\n\n    #allPosition;\n    #pinnedPositionLinks;\n    #pinnedPositionGroups;\n\n    constructor() {\n        this.#databaseName = 'Primary';\n        this.#databaseVersion = '2';\n    } \n\n    bindLinkbookDataChanged(callback) {\n        this.#onLinkbookDataChanged = callback;\n    }\n\n    bindErrorHandle(handle) {\n        this.#onErrorHandle = handle;\n    }\n\n    async compileLinkbookData() {\n        const links = await this.getLinksIndexedByAllPosition();\n        const groups = await this.getGroupsIndexedByAllPosition();\n        this.#allPosition = 0;\n        this.#pinnedPositionLinks = 0;\n        this.#pinnedPositionGroups = 0;\n\n        const groupChildren = new Map();\n        groupChildren.set(0, []);       \n        for(const group of groups) {\n            if(group.allPosition > this.#allPosition) this.#allPosition = group.allPosition;\n            if(group.pinnedPosition > this.#pinnedPositionGroups) this.#pinnedPositionGroups = group.pinnedPosition;\n            if(groupChildren.has(group.id)) continue;\n            groupChildren.set(group.id, []);       \n        }\n\n        for(const link of links) {\n            const typedLink = {...link, type: 'link'};\n            if(link.parent === 0 && link.allPosition > this.#allPosition) this.#allPosition = link.allPosition;\n            if(link.parent === 0 && link.pinnedPosition > this.#pinnedPositionLinks) this.#pinnedPositionLinks = link.pinnedPosition;\n            groupChildren.set(link.parent, [...groupChildren.get(link.parent), typedLink]);\n        }\n\n        const groupArray = [];\n        let baseLinkArray;\n        for(const [groupId, children] of groupChildren) {\n            if(groupId === 0) {\n                baseLinkArray = children;\n                continue;\n            }                 \n\n            const group = {...await this.getGroup(groupId), type: 'group', children: []};\n            groupArray.push(group);\n\n            for(const link of children) {\n                group.children.push(link);\n            }\n        }\n\n        let data = [];\n        let i = 0, j = 0;\n        for(; i < groupArray.length && j < baseLinkArray.length; ) {\n            if(groupArray[i].allPosition < baseLinkArray[j].allPosition) {\n                data.push(groupArray[i]);\n                i++;\n            } else {\n                data.push(baseLinkArray[j]);\n                j++;\n            }\n        }\n\n        while(i < groupArray.length) {\n            data.push(groupArray[i]);\n            i++;\n        }\n\n        while(j < baseLinkArray.length) {\n            data.push(baseLinkArray[j]);\n            j++;\n        }\n\n        return data;\n    }\n\n    async #initializeDatabase() {\n        this.#localDB = await (0,idb__WEBPACK_IMPORTED_MODULE_0__.openDB)(this.#databaseName, this.#databaseVersion, {\n            upgrade(db) {\n                const links = db.createObjectStore('linkbookLinks', {keyPath: 'id', autoIncrement: true});\n                links.createIndex('parent', 'parent');\n                links.createIndex('allPosition', 'allPosition');\n                links.createIndex('pinnedPosition', 'pinnedPosition');\n                const groups = db.createObjectStore('linkbookGroups', {keyPath: 'id', autoIncrement: true});\n                groups.createIndex('allPosition', 'allPosition');\n                groups.createIndex('pinnedPosition', 'pinnedPosition');\n            }\n        });\n    }\n\n    async createLink(name, link, parent, isPinned) {\n        if(!this.#localDB) await this.#initializeDatabase();\n        let linkId;\n        let linkData;\n\n        try {\n            if(!name) {\n                throw new SystemError('Create link called with unspecified name!');\n            }\n\n            if(!link) {\n                throw new SystemError('Create link called with unspecified link!');\n            }\n\n            if(typeof name !== 'string') {\n                throw new SystemError('Create link called with non string name!');\n            }\n\n            if(typeof link !== 'string') {\n                throw new SystemError('Create link called with non string link!');\n            }\n            \n            if(name.trim().length === 0) {\n                throw new UserError('Try again by specifying a name for your link shortcut!');\n            }\n\n            if(link.trim().length === 0) {\n                throw new UserError('Try again by specifying a link for your link shortcut!');\n            }\n        } catch(err) {\n            this.#onErrorHandle(err);\n            return null;\n        }\n\n        if(!parent || typeof parent !== 'number' || parent < 0) {\n            parent = 0;\n        }\n\n        if(!isPinned || typeof isPinned !== 'boolean') {\n            isPinned = false;\n        }\n\n        let allPosition = this.#allPosition + 1000;\n        if(parent !== 0) {\n            allPosition = (await this.getGroup(parent)).groupPosition + 1000;\n            await this.#editGroupElementPosition(parent, allPosition);\n        }\n\n        linkData = {\n            name, \n            link, \n            parent, \n            isPinned,\n            allPosition,\n            pinnedPosition: isPinned ? this.#pinnedPositionLinks + 1000 : 0\n        };\n\n        try {\n            linkId = await this.#localDB.put('linkbookLinks', linkData);\n        } catch (err) {\n            const linkSaveError = new SystemError(err);\n            this.#onErrorHandle(linkSaveError);\n            return null;\n        }\n\n        this.#onLinkbookDataChanged(await this.compileLinkbookData());\n        return {id: linkId, ...linkData};\n    }\n\n    async getLink(linkId) {\n        if(!this.#localDB) await this.#initializeDatabase();\n        let data;\n\n        try {\n            data = await this.#localDB.get('linkbookLinks', linkId);\n            if(!data) data = null;\n        } catch(err) {\n            const getLinkError = new SystemError(err);\n            this.#onErrorHandle(getLinkError);\n            data = null;\n        }\n\n        return data;\n    }\n\n    async getLinks() {\n        if(!this.#localDB) await this.#initializeDatabase();\n        let links;\n        \n        try {\n            links = await this.#localDB.getAll('linkbookLinks');\n        } catch(err) {\n            const getLinksError = new SystemError(err);\n            this.#onErrorHandle(getLinksError);\n            links = [];\n        }\n\n        return links;\n    }\n\n    async getLinksIndexedByAllPosition() {\n        if(!this.#localDB) await this.#initializeDatabase();\n        let data;\n\n        try {\n            data = await this.#localDB.getAllFromIndex('linkbookLinks', 'allPosition');\n            if(!data) data = [];\n        } catch(err) {\n            const getLinkError = new SystemError(err);\n            this.#onErrorHandle(getLinkError);\n            data = [];\n        }\n\n        return data;\n    }\n\n    async editLinkNameAndLink(linkId, newName, newLink) {\n        if(!this.#localDB) await this.#initializeDatabase();\n\n        const oldLinkData = await this.getLink(linkId);\n        if(!oldLinkData) {\n            nullDataError = new SystemError('Unable to edit link as it might have been deleted!');\n            this.#onErrorHandle(nullDataError);\n            return null;\n        }\n        let newLinkData;\n\n        try {\n            if(!newName || !newLink) {\n                throw new SystemError('Edit link called with unspecified newName or newLink!');\n            }\n\n            if(typeof newName !== 'string' || typeof newLink !== 'string') {\n                throw new SystemError('Edit link called with non string newName or newLink!');\n            } \n        } catch(err) {\n            this.#onErrorHandle(err);\n            return null;\n        }\n\n        if(newName.trim().length === 0) {\n            newName = oldLinkData.name;\n        }\n\n        if(newLink.trim().length === 0) {\n            newLink = oldLinkData.link;\n        }\n\n        newLinkData = {...oldLinkData, name: newName, link: newLink};\n\n        try {\n            await this.#localDB.put('linkbookLinks', newLinkData);\n        } catch(err) {\n            const editLinkError = new SystemError(err);\n            this.#onErrorHandle(editLinkError);\n            return null;\n        }\n            \n        this.#onLinkbookDataChanged(await this.compileLinkbookData());\n        return newLinkData;\n    }\n\n    async deleteLink(linkId) {\n        if(!this.#localDB) await this.#initializeDatabase();\n        const data = await this.getLink(linkId);\n\n        if(!data) {\n            nullDataError = new SystemError('Unable to delete link as it might have already been deleted!');\n            this.#onErrorHandle(nullDataError);\n            return null;\n        }\n\n        try {\n            await this.#localDB.delete('linkbookLinks', linkId);\n        } catch(err) {\n            const deleteLinkError = new SystemError(err);\n            this.#onErrorHandle(deleteLinkError);\n            return null;\n        }\n\n        this.#onLinkbookDataChanged(await this.compileLinkbookData());\n        return linkId;\n    }\n\n    async editLinkPin(linkId, isPinned) {\n        if(!this.#localDB) await this.#initializeDatabase();\n        const data = await this.getLink(linkId);\n\n        if(!data) {\n            nullDataError = new SystemError('Unable to edit link\\'s pin mode as it might have been deleted!');\n            this.#onErrorHandle(nullDataError);\n            return null;\n        }\n\n        data.isPinned = isPinned;\n        data.pinnedPosition = isPinned ? this.#pinnedPositionLinks + 1000 : 0;\n\n        try {\n            await this.#localDB.put('linkbookLinks', data);\n        } catch(err) {\n            const editLinkPinError = new SystemError(err);\n            this.#onErrorHandle(editLinkPinError);\n            return null;\n        }\n\n        this.#onLinkbookDataChanged(await this.compileLinkbookData());\n        return data;\n    }\n\n    async editLinkPosition(linkId, position, category) {\n        // MAKE THIS WORK FOR ALL TYPES OF POSITIONS\n        if(!this.#localDB) await this.#initializeDatabase();\n        const data = await this.getLink(linkId);\n\n        if(!data) {\n            nullDataError = new SystemError('Unable to edit link\\'s pin mode as it might have been deleted!');\n            this.#onErrorHandle(nullDataError);\n            return null;\n        }\n\n        if(category === 'all') {\n            data.allPosition = position;\n        } else {\n            data.pinnedPosition = position;\n        }\n\n        try {\n            await this.#localDB.put('linkbookLinks', data);\n        } catch(err) {\n            const editLinkPositionError = new SystemError(err);\n            this.#onErrorHandle(editLinkPositionError);\n            return null;\n        }\n\n        this.#onLinkbookDataChanged(await this.compileLinkbookData());\n        return data;\n    }\n\n    async editLinkParent(linkId, parent) {\n        if(!this.#localDB) await this.#initializeDatabase();\n        const data = await this.getLink(linkId);\n        const oldParent = await this.getGroup(data.parent);\n        const newParent = await this.getGroup(parent);\n\n        if(!data) {\n            nullDataError = new SystemError('Unable to edit link\\'s pin mode as it might have been deleted!');\n            this.#onErrorHandle(nullDataError);\n            return null;\n        }\n\n        if(oldParent && oldParent.groupPosition === data.allPosition) {\n            // find the last largest element and then edit groups element position\n            let cursorLinks = await this.#localDB.transaction('linkbookLinks', 'readonly')\n                .objectStore('linkbookLinks')\n                .index('allPosition')\n                .openCursor(\n                    IDBKeyRange.upperBound(data.allPosition),\n                    'prev'\n                );\n\n            // ignore every similar value of a different parent\n            while(cursorLinks && cursorLinks.value.allPosition === data.allPosition) {\n                cursorLinks = await cursorLinks.continue();\n            }\n\n            // find an adjacent value with a similar parent\n            while(cursorLinks && cursorLinks.value.parent !== oldParent.id) {\n                cursorLinks = await cursorLinks.continue();\n            }\n\n            await this.#editGroupElementPosition(oldParent.id, cursorLinks ? cursorLinks.value.allPosition : 0);\n        }\n\n        data.parent = parent;\n        if(newParent) {\n            data.allPosition = newParent.groupPosition + 1000;\n            this.#editGroupElementPosition(newParent.id, newParent.groupPosition + 1000);\n        } else {\n            data.allPosition = this.#allPosition + 1000;\n        }\n\n        try {\n            await this.#localDB.put('linkbookLinks', data);\n        } catch(err) {\n            const editLinkParentError = new SystemError(err);\n            this.#onErrorHandle(editLinkParentError);\n            return null;\n        }\n\n        this.#onLinkbookDataChanged(await this.compileLinkbookData());\n        return data;\n    }\n\n    async createGroup(isPinned) {\n        if(!this.#localDB) await this.#initializeDatabase();\n        let groupId;\n        let group; \n\n        if(!isPinned || typeof isPinned !== 'boolean') {\n            isPinned = false;\n        }\n\n        group = {\n            name: '', \n            isPinned,\n            allPosition: this.#allPosition + 1000,\n            pinnedPosition: isPinned ? this.#pinnedPositionLinks + 1000: 0,\n            groupPosition: 0\n        };\n\n        try {\n            groupId = await this.#localDB.put('linkbookGroups', group);\n        } catch(err) {\n            const createGroupError = new SystemError(err);\n            this.#onErrorHandle(createGroupError);\n            return null;\n        }\n\n        this.#onLinkbookDataChanged(await this.compileLinkbookData());\n        return {id: groupId, ...group};\n    }\n\n    async getGroup(groupId) {\n        if(!this.#localDB) await this.#initializeDatabase();\n        let data;\n\n        try {\n            data = await this.#localDB.get('linkbookGroups', groupId);\n            if(!data) data = null;\n        } catch(err) {\n            const getGroupError = new SystemError(err);\n            this.#onErrorHandle(getGroupError);\n            return null;\n        }\n\n        return data;\n    }\n\n    async getGroups() {\n        if(!this.#localDB) await this.#initializeDatabase();\n        let data;\n\n        try {\n            data =  await this.#localDB.getAll('linkbookGroups');\n        } catch(err) {\n            const getGroupsError = new SystemError(err);\n            this.#onErrorHandle(getGroupsError);\n            data = [];\n        }\n\n        return data;\n    }\n\n    async getGroupsIndexedByAllPosition() {\n        if(!this.#localDB) await this.#initializeDatabase();\n        let data;\n\n        try {\n            data = await this.#localDB.getAllFromIndex('linkbookGroups', 'allPosition');\n            if(!data) data = [];\n        } catch(err) {\n            const getLinkError = new SystemError(err);\n            this.#onErrorHandle(getLinkError);\n            data = [];\n        }\n\n        return data;\n    }\n\n    async getGroupChildren(groupId) {\n        if(!this.#localDB) await this.#initializeDatabase();\n\n        let children;\n        const group = this.getGroup(groupId);\n        if(!group) {\n            nullGroupError = new SystemError('Unable to get group\\'s children as it might have been deleted!');\n            this.#onErrorHandle(nullGroupError);\n            return null;\n        }\n\n        try {\n            children = await this.#localDB.getAllFromIndex('linkbookLinks', 'parent', groupId);\n        } catch(err) {\n            const getChildrenError = new SystemError(err);\n            this.#onErrorHandle(getChildrenError);\n            children = [];\n        }\n\n        return children;\n    }\n\n    async editGroupName(groupId, newName) {\n        if(!this.#localDB) await this.#initializeDatabase();\n        \n        const oldGroup = await this.getGroup(groupId);\n        if(!oldGroup) {\n            nullGroupError = new SystemError('Unable to edit group as it might have been deleted!');\n            this.#onErrorHandle(nullGroupError);\n            return null;\n        }\n        const newGroup = {...oldGroup, name: newName};\n\n        try {\n            await this.#localDB.put('linkbookGroups', newGroup);\n        } catch(err) {\n            const editGroupError = new SystemError(err);\n            this.#onErrorHandle(editGroupError);\n            return null;\n        }\n\n        this.#onLinkbookDataChanged(await this.compileLinkbookData());\n        return newGroup;\n    }\n\n    async deleteGroup(groupId) {\n        if(!this.#localDB) await this.#initializeDatabase();\n        const data = await this.getGroup(groupId);\n        if(!data) {\n            nullGroupError = new SystemError('Unable to delete group as it might have already been deleted!');\n            this.#onErrorHandle(nullGroupError);\n            return null;\n        }\n\n        try {\n            await this.#localDB.delete('linkbookGroups', groupId);\n        } catch(err) {\n            const deleteGroupError = new SystemError(err);\n            this.#onErrorHandle(deleteGroupError);\n            return null;\n        }\n\n        this.#onLinkbookDataChanged(await this.compileLinkbookData());\n        return data;\n    }\n\n    async editGroupPin(groupId, isPinned) {\n        if(!this.#localDB) await this.#initializeDatabase();\n\n        const data = await this.getGroup(groupId);\n        if(!data) {\n            nullGroupError = new SystemError('Unable to edit group\\'s pin mode as it might have been deleted!');\n            this.#onErrorHandle(nullGroupError);\n            return null;\n        }\n        data.isPinned = isPinned;\n        data.pinnedPosition = isPinned ? this.#pinnedPositionGroups + 1000 : 0;\n\n        try {\n            await this.#localDB.put('linkbookGroups', data);\n        } catch(err) {\n            const deleteGroupError = new SystemError(err);\n            this.#onErrorHandle(deleteGroupError);\n            return null;\n        }\n\n        this.#onLinkbookDataChanged(await this.compileLinkbookData());\n        return data;\n    }\n\n    async editGroupPosition(groupId, position, category) {\n        // MAKE THIS WORK FOR ALL TYPES OF POSITIONS\n        if(!this.#localDB) await this.#initializeDatabase();\n        const data = await this.getGroup(groupId);\n\n        if(!data) {\n            nullDataError = new SystemError('Unable to edit group\\'s position as it might have been deleted!');\n            this.#onErrorHandle(nullDataError);\n            return null;\n        }\n\n        if(category === 'all') {\n            data.allPosition = position;\n        } else {\n            data.pinnedPosition = position;\n        }\n\n        try {\n            await this.#localDB.put('linkbookGroups', data);\n        } catch(err) {\n            const editGroupPositionError = new SystemError(err);\n            this.#onErrorHandle(editGroupPositionError);\n            return null;\n        }\n\n        this.#onLinkbookDataChanged(await this.compileLinkbookData());\n        return data;\n    }\n\n    async #editGroupElementPosition(groupId, newPosition) {\n        if(!this.#localDB) await this.#initializeDatabase();\n        \n        const oldGroup = await this.getGroup(groupId);\n        if(!oldGroup) {\n            nullGroupError = new SystemError('Unable to edit group as it might have been deleted!');\n            this.#onErrorHandle(nullGroupError);\n            return null;\n        }\n        const newGroup = {...oldGroup, groupPosition: newPosition};\n\n        try {\n            await this.#localDB.put('linkbookGroups', newGroup);\n        } catch(err) {\n            const editGroupError = new SystemError(err);\n            this.#onErrorHandle(editGroupError);\n            return null;\n        }\n\n        return newGroup;\n    }\n\n    async relocate(relocationData) {\n        if(relocationData.selectedType === relocationData.newPositionType && relocationData.selectedId === relocationData.newPositionId) return;\n        \n        if(relocationData.selectedType === 'link' && relocationData.newPositionType === 'link') {\n            let currentLink = await this.getLink(relocationData.selectedId);\n            const newPositionLink = await this.getLink(relocationData.newPositionId); \n            let isCurrentLinkInsideGroup = currentLink.parent !== 0;\n\n            const isRelocatingInPinned = relocationData.relocationCategory === 'pinned';\n            let currentLinkPosition = !isRelocatingInPinned ? currentLink.allPosition : currentLink.pinnedPosition;\n            let newPositionLinkPosition = !isRelocatingInPinned ? newPositionLink.allPosition : newPositionLink.pinnedPosition;\n            const dbIndex = !isRelocatingInPinned ? 'allPosition' : 'pinnedPosition';\n            const cursorPositionValue = (cursor, isRelocatingInPinned) => { return !isRelocatingInPinned ? cursor.value.allPosition : cursor.value.pinnedPosition; };\n\n            if(\n                isRelocatingInPinned && \n                (!currentLink.isPinned || !newPositionLink.isPinned)\n            ) return;\n\n            if(currentLink.parent !== newPositionLink.parent) {\n                await this.editLinkParent(currentLink.id, newPositionLink.parent);\n                currentLink = await this.getLink(currentLink.id);\n                isCurrentLinkInsideGroup = currentLink.parent !== 0;\n            }\n\n            if(currentLink.parent !== 0) {\n                const currentGroup = await this.getGroup(currentLink.parent);\n                if(currentGroup.groupPosition === currentLinkPosition) return;\n            }\n\n            let cursorLinks = await this.#localDB.transaction('linkbookLinks', 'readonly')\n                .objectStore('linkbookLinks')\n                .index(dbIndex)\n                .openCursor(\n                    relocationData.newPositionDirection === 'above' ? \n                        IDBKeyRange.lowerBound(newPositionLinkPosition) :\n                        IDBKeyRange.upperBound(newPositionLinkPosition),\n                    relocationData.newPositionDirection === 'above' ? 'next' : 'prev'\n                );\n\n            while(cursorLinks && cursorPositionValue(cursorLinks, isRelocatingInPinned) === newPositionLinkPosition) {\n                cursorLinks = await cursorLinks.continue();\n            }\n\n            while(cursorLinks && cursorLinks.value.parent !== newPositionLink.parent) {\n                cursorLinks = await cursorLinks.continue();\n            }\n\n            let cursorGroups = null;\n            if(!isCurrentLinkInsideGroup) {\n                cursorGroups = await this.#localDB.transaction('linkbookGroups', 'readonly')\n                    .objectStore('linkbookGroups')\n                    .index(dbIndex)\n                    .openCursor(\n                        relocationData.newPositionDirection === 'above' ? \n                        IDBKeyRange.lowerBound(newPositionLinkPosition) :\n                        IDBKeyRange.upperBound(newPositionLinkPosition),\n                        relocationData.newPositionDirection === 'above' ? 'next' : 'prev'\n                    );\n\n                while(cursorGroups && cursorPositionValue(cursorGroups, isRelocatingInPinned) === newPositionLinkPosition) {\n                    cursorGroups = await cursorGroups.continue();\n                }\n            }\n\n            let nextElement = null;\n            if(!isRelocatingInPinned && cursorLinks && cursorGroups) {\n                if(\n                    (relocationData.newPositionDirection === 'above' && cursorPositionValue(cursorLinks, isRelocatingInPinned) < cursorPositionValue(cursorGroups, isRelocatingInPinned)) ||\n                    (relocationData.newPositionDirection === 'below' && cursorPositionValue(cursorLinks, isRelocatingInPinned) > cursorPositionValue(cursorGroups, isRelocatingInPinned))\n\n                ) {\n                    nextElement = cursorLinks.value;\n                } else {\n                    nextElement = cursorGroups.value;\n                }\n            } else if(isRelocatingInPinned && cursorLinks && !cursorGroups) {\n                nextElement = cursorLinks.value;\n            } else if(!isRelocatingInPinned && !cursorLinks && cursorGroups) {\n                nextElement = cursorGroups.value;\n            }\n\n            if(!nextElement) {\n                if(relocationData.newPositionDirection === 'above') {\n                    currentLinkPosition = newPositionLinkPosition + 1000;\n                } else {\n                    currentLinkPosition = newPositionLinkPosition - Math.floor(newPositionLinkPosition / 2);\n                }\n            } else {\n                    currentLinkPosition = Math.floor((newPositionLinkPosition + (!isRelocatingInPinned ? nextElement.allPosition : nextElement.pinnedPosition)) / 2);\n            }\n            \n            await this.editLinkPosition(currentLink.id, currentLinkPosition, relocationData.relocationCategory);\n        } else if(relocationData.selectedType === 'link' && relocationData.newPositionType === 'group') {\n            const currentLink = await this.getLink(relocationData.selectedId);\n            if(currentLink.parent === relocationData.newPositionId) return;\n            await this.editLinkParent(relocationData.selectedId, relocationData.newPositionId);\n        } else {\n            const isRelocatingInPinned = relocationData.relocationCategory === 'pinned';\n            // Prevent illegal moves\n            if(\n                isRelocatingInPinned && \n                (\n                    relocationData.selectedId === 0 || \n                    (isRelocatingInPinned && relocationData.newPositionId === 0 && relocationData.newPositionDirection === 'below')\n                )\n            ) return;\n\n            const currentElement = await this.getGroup(relocationData.selectedId);\n            const newPositionElement = relocationData.newPositionType === 'link' ? \n                await this.getLink(relocationData.newPositionId) :\n                await this.getGroup(relocationData.newPositionId);\n            let currentElementPosition = !isRelocatingInPinned ? currentElement.allPosition : currentElement.pinnedPosition;\n            let newPositionElementPosition = !isRelocatingInPinned ? newPositionElement.allPosition : newPositionElement.pinnedPosition;\n            const dbIndex = !isRelocatingInPinned ? 'allPosition' : 'pinnedPosition';\n            const cursorPositionValue = (cursor, isRelocatingInPinned) => { return !isRelocatingInPinned ? cursor.value.allPosition : cursor.value.pinnedPosition; };\n\n            let cursorLinks = await this.#localDB.transaction('linkbookLinks', 'readonly')\n                .objectStore('linkbookLinks')\n                .index(dbIndex)\n                .openCursor(\n                    relocationData.newPositionDirection === 'above' ? \n                        IDBKeyRange.lowerBound(newPositionElementPosition) :\n                        IDBKeyRange.upperBound(newPositionElementPosition),\n                    relocationData.newPositionDirection === 'above' ? 'next' : 'prev'\n                );\n\n            while(cursorLinks && cursorPositionValue(cursorLinks, isRelocatingInPinned) === newPositionElementPosition) {\n                cursorLinks = await cursorLinks.continue();\n            }\n\n            while(cursorLinks && cursorLinks.value.parent !== 0) {\n                cursorLinks = await cursorLinks.continue();\n            }\n\n            let cursorGroups = await this.#localDB.transaction('linkbookGroups', 'readonly')\n                .objectStore('linkbookGroups')\n                .index(dbIndex)\n                .openCursor(\n                    relocationData.newPositionDirection === 'above' ? \n                    IDBKeyRange.lowerBound(newPositionElementPosition) :\n                    IDBKeyRange.upperBound(newPositionElementPosition),\n                    relocationData.newPositionDirection === 'above' ? 'next' : 'prev'\n                );\n\n            while(cursorGroups && cursorPositionValue(cursorGroups, isRelocatingInPinned) === newPositionElementPosition) {\n                cursorGroups = await cursorGroups.continue();\n            }\n\n            let nextElement = null;\n            if(!isRelocatingInPinned && cursorLinks && cursorGroups) {\n                if(\n                    (relocationData.newPositionDirection === 'above' && cursorPositionValue(cursorLinks, isRelocatingInPinned) < cursorPositionValue(cursorGroups, isRelocatingInPinned)) ||\n                    (relocationData.newPositionDirection === 'below' && cursorPositionValue(cursorLinks, isRelocatingInPinned) > cursorPositionValue(cursorGroups, isRelocatingInPinned))\n                ) {\n                    nextElement = cursorLinks.value;\n                } else {\n                    nextElement = cursorGroups.value;\n                }\n            } else if(!isRelocatingInPinned && cursorLinks && !cursorGroups) {\n                nextElement = cursorLinks.value;\n            } else if(isRelocatingInPinned && !cursorLinks && cursorGroups) {\n                nextElement = cursorGroups.value;\n            }\n\n            if(!nextElement) {\n                if(relocationData.newPositionDirection === 'above') {\n                    currentElementPosition = newPositionElementPosition + 1000;\n                } else {\n                    currentElementPosition = newPositionElementPosition - Math.floor(newPositionElementPosition / 2);\n                }\n            } else {\n                currentElementPosition = Math.floor((newPositionElementPosition + !isRelocatingInPinned ? nextElement.allPosition : nextElement.pinnedPosition) / 2);\n            }\n\n            await this.editGroupPosition(currentElement.id, currentElementPosition, relocationData.relocationCategory);\n        }\n    }\n}\n\nclass LinkbookView {\n    #app;\n    #pinnedLinksCategory;\n    #pinnedLinksNewLinkButton;\n    #pinnedLinksNewGroupButton;\n    #pinnedLinksList;\n    #pinnedLinksDisplay;\n\n    #allLinksCategory;\n    #allLinksNewLinkButton;\n    #allLinksNewGroupButton;\n    #allLinksList;\n\n    #linkDataForm;\n    #linkDataDetails;\n    #linkDataFormNameField;\n    #linkDataFormNameError;\n    #linkDataFormLinkField;\n    #linkDataFormLinkError;\n    #linkDataFormSaveLinkButton;\n    #linkDataFormExitButton;\n\n    #optionsMenu;\n    #optionsMenuPin;\n    #optionsMenuUnPin;\n    #optionsMenuEdit;\n    #optionsMenuDelete;\n\n    #alertbox;\n    #alertboxPrompt;\n    #alertboxYesButton;\n    #alertboxNoButton;\n\n    #onOpenLink;\n    #onOpenLinkDataForm;\n    #onOpenOptionsMenu;\n    #onGroupEditSave;\n    #onSelectForRelocation;\n    #onRelocateActivate;\n    #onRelocateSuccess;\n\n    #selectedElement;\n    #selectedType;\n\n    constructor() {\n        this.#app = this.getElement('.content');\n        this.#pinnedLinksCategory = this.getElement('#linkbook-category-pinned-links');\n        this.#pinnedLinksNewLinkButton = this.getElement('[data-id=\"add-link-button\"]', this.#pinnedLinksCategory);\n        this.#pinnedLinksNewGroupButton = this.getElement('[data-id=\"add-group-button\"]', this.#pinnedLinksCategory);\n        this.#pinnedLinksList = this.getElement('[data-id=\"linkbook-links-list\"]', this.#pinnedLinksCategory);\n        this.#pinnedLinksDisplay = this.getElement('.pinned-groups');\n\n        this.#allLinksCategory = this.getElement('#linkbook-category-all-links');\n        this.#allLinksNewLinkButton = this.getElement('[data-id=\"add-link-button\"]', this.#allLinksCategory);\n        this.#allLinksNewGroupButton = this.getElement('[data-id=\"add-group-button\"]', this.#allLinksCategory);\n        this.#allLinksList = this.getElement('[data-id=\"linkbook-links-list\"]', this.#allLinksCategory);\n\n        this.#linkDataForm = this.getElement('.link-content-form');\n        this.#linkDataDetails = this.getElement('.link-content-form__details', this.#linkDataForm);\n        this.#linkDataFormNameField = this.getElement('[name=\"link-form-name\"]', this.#linkDataForm);\n        this.#linkDataFormNameError = this.getElement('#link-form-name-error');\n        this.#linkDataFormLinkField = this.getElement('[name=\"link-form-link\"]', this.#linkDataForm);\n        this.#linkDataFormLinkError = this.getElement('#link-form-link-error');\n        this.#linkDataFormSaveLinkButton = this.getElement('.link-form-buttons__submit', this.#linkDataForm);\n        this.#linkDataFormExitButton = this.getElement('.link-content-form__details-exit', this.#linkDataForm);\n        \n        this.#optionsMenu = this.getElement('.link-options-menu');\n        this.#optionsMenuPin = this.getElement('#link-options-menu-pin', this.#optionsMenu);\n        this.#optionsMenuUnPin = this.getElement('#link-options-menu-unpin', this.#optionsMenu);\n        this.#optionsMenuEdit = this.getElement('#link-options-menu-edit', this.#optionsMenu);\n        this.#optionsMenuDelete = this.getElement('#link-options-menu-delete', this.#optionsMenu);\n\n        this.#alertbox = this.getElement('.alertbox');\n        this.#alertboxPrompt = this.getElement('.alertbox__text');\n        this.#alertboxYesButton = this.getElement('.alertbox__button--yes');\n        this.#alertboxNoButton = this.getElement('.alertbox__button--no');\n\n\n        this.#pinnedLinksList.addEventListener('mousemove', event => {\n            if(event.buttons !== 1) return;\n            if(this.#selectedElement && this.#selectedElement.getAttribute('data-location') === 'all') return;\n            this.#pinnedLinksList.classList.add('js-move');\n            if(this.#selectedElement) this.#selectedElement.classList.add('js-selected-element');\n        });\n\n        this.#allLinksList.addEventListener('mousemove', event => {\n            if(event.buttons !== 1) return;\n            if(this.#selectedElement && this.#selectedElement.getAttribute('data-location') === 'pinned') return;\n            this.#allLinksList.classList.add('js-move');\n            if(this.#selectedElement) this.#selectedElement.classList.add('js-selected-element');\n        });\n    }\n\n    getElement(selector, parent) {\n        if(!parent) parent = document;\n        const element = parent.querySelector(selector);\n        return element;\n    }\n\n    createElement(tag, ...className) {\n        const element = document.createElement(tag);\n        for(let i = 1; i < arguments.length; i++) {\n            element.classList.add(arguments[i]);\n        }\n\n        return element;\n    }\n\n    bindOpenLinkDataForm(handler) {\n        this.#onOpenLinkDataForm = handler;\n        this.#pinnedLinksNewLinkButton.addEventListener('click', _ => this.#onOpenLinkDataForm(0, true));\n        this.#allLinksNewLinkButton.addEventListener('click', _ => this.#onOpenLinkDataForm(0, false));\n    }\n\n    bindCreateGroup(handler) {\n        this.#pinnedLinksNewGroupButton.addEventListener('click', _ => handler(true));\n        this.#allLinksNewGroupButton.addEventListener('click', _ => handler(false));\n    }\n\n    bindCloseLinkDataForm(handler) {\n        const cleanupForm = () => {\n            this.#linkDataFormNameField.value = '';\n            this.#linkDataFormLinkField.value = '';\n            handler();\n        }\n\n        this.#linkDataForm.addEventListener('click', event => {\n            if(event.currentTarget !== event.target) return\n            cleanupForm();\n        });\n\n        this.#linkDataFormExitButton.addEventListener('click', event => {\n            event.preventDefault();\n            cleanupForm();\n        });\n    }\n\n    bindSaveLinkDataForm(handler) {\n        this.#linkDataFormSaveLinkButton.addEventListener('click', event => {\n            event.preventDefault();\n            if(!this.#linkDataDetails.checkValidity()) return;\n\n            const data = {\n                name: this.#linkDataFormNameField.value,\n                link: this.#linkDataFormLinkField.value\n            };\n            if(this.#linkDataForm.getAttribute('data-id')) {\n                data.id = parseInt(this.#linkDataForm.getAttribute('data-id'));\n                this.#linkDataForm.removeAttribute('data-id');\n            }\n\n            handler(data);\n        });\n\n        this.#linkDataFormNameField.setAttribute('aria-invalid', 'false');\n        this.#linkDataFormNameField.addEventListener('invalid', event => {\n            invalidate(event);\n        });\n\n        this.#linkDataFormNameField.addEventListener('input', event => {\n            this.#linkDataFormNameField.setAttribute('aria-invalid', 'false');\n        });\n\n        this.#linkDataFormLinkField.setAttribute('aria-invalid', 'false');\n        this.#linkDataFormLinkField.addEventListener('invalid', event => {\n            invalidate(event);\n        });\n\n        this.#linkDataFormLinkField.addEventListener('input', event => {\n            this.#linkDataFormLinkField.setAttribute('aria-invalid', 'false');\n        });\n        \n        const invalidate = event => {\n            switch(event.target.name) {\n                case 'link-form-name':\n                    this.#linkDataFormNameField.setAttribute('aria-invalid', 'true');\n                    this.#linkDataFormNameError.textContent = event.target.validationMessage;\n                    break;\n                case 'link-form-link':\n                    this.#linkDataFormLinkField.setAttribute('aria-invalid', 'true');\n                    this.#linkDataFormLinkError.textContent = event.target.validationMessage;\n                    break;\n                default:\n                    console.error('This element doesn\\'t have an error box');\n            }\n        };\n    }\n\n    bindGroupEditSave(handler) {\n        this.#onGroupEditSave = handler;\n    }\n\n    bindOpenOptionsMenu(handler) {\n        this.#onOpenOptionsMenu = handler;\n    }\n\n    bindCloseOptionsMenu(handler) {\n        this.#optionsMenuPin.onclick = null;\n        this.#optionsMenuUnPin.onclick = null;\n        this.#optionsMenuEdit.onclick = null;\n        this.#optionsMenuDelete.onclick = null;\n\n        this.#app.addEventListener('click', event => {\n            if(event.target.classList.contains('options-button__icon')) {\n                return;\n            }\n            handler();\n        });\n    }\n\n    bindOpenLink(handler) {\n        this.#onOpenLink = handler;\n    }\n\n    bindOptionsMenuPin(handler) {\n       this.#optionsMenuPin.onclick = handler; \n    }\n\n    bindOptionsMenuUnpin(handler) {\n        this.#optionsMenuUnPin.onclick = handler;\n    }\n\n    bindOptionsMenuEdit(handler) {\n        this.#optionsMenuEdit.onclick = handler;\n    }\n\n    bindOptionsMenuDelete(handler) {\n        this.#optionsMenuDelete.onclick = handler;\n    }\n\n    bindSelectForRelocation(handler) {\n        this.#onSelectForRelocation = handler;\n    }\n\n    bindRelocationActivate(handler) {\n        this.#onRelocateActivate = handler;\n    }\n\n    bindRelocateSuccess(handler) {\n        this.#onRelocateSuccess = handler;\n    }\n\n    bindRelocateCancel(handler) {\n        this.#app.addEventListener('mouseup', event => {\n            handler();\n        });\n    }\n\n    #createLinkDisplay(linkData, isPinned, location) {\n        const linkRoot = this.createElement('button', 'linkbook-browser-links-group__link-item');\n        const linkDetails = this.createElement('div', 'linkbook-browser-links-group__link-item-details');\n        const linkImg = this.createElement('img', 'linkbook-browser-links-group__link-item-icon');   \n        const linkNameText = this.createElement('span', 'linkbook-browser-links-group__link-item-name');\n\n        linkImg.src = `https://www.google.com/s2/favicons?domain=${linkData.link}&sz=64`;\n        // answer \n        // is link show pinned, when is it inside pinned, when linkData.isPinned but this shows everywhere else regardless\n        // so ughhhh when does it only show there?\n        // everywhere else show basic\n        linkNameText.textContent = linkData.name;\n\n        linkRoot.setAttribute('data-id', `${linkData.id}-${linkData.type}`);\n        linkRoot.setAttribute('data-location', location);\n\n        linkRoot.append(linkDetails);\n        linkDetails.append(linkImg, linkNameText);\n\n        let isOpenable = true;\n\n        linkRoot.addEventListener('mouseup', event => {\n            if(!isOpenable) {\n                isOpenable = true;\n                return;\n            }\n            if(\n                event.target.classList.contains('options-button__icon') ||\n                event.target.classList.contains('button--small')\n            ) return;\n\n            const openInNewTab = !event.altKey;\n            this.#onOpenLink(linkData.link, openInNewTab);\n        });\n\n        linkRoot.addEventListener('contextmenu', event => {\n            event.preventDefault();\n            event.stopPropagation();\n\n            isOpenable = false;\n            this.#onOpenOptionsMenu(linkRoot, linkData.type, linkData.id, isPinned, {pin: !isPinned, unpin: isPinned && location === 'pinned', edit: true, delete: true});\n        });\n\n        linkRoot.addEventListener('mousemove', event => {\n            if(!this.#selectedElement) return;\n\n            if(\n                this.#selectedElement && (\n                    this.#selectedElement.getAttribute('data-location').includes('all') && !location.includes('all') ||\n                    this.#selectedElement.getAttribute('data-location').includes('pinned') && !location.includes('pinned')\n                )\n            ) return;\n\n            if(this.#selectedType === 'group' && linkData.parent !== 0) return;\n            const rootData = linkRoot.getBoundingClientRect();\n\n            event.currentTarget.classList.remove('js-hovered-link-top');\n            event.currentTarget.classList.remove('js-hovered-link-bottom');\n            if(event.clientY < rootData.y + rootData.height / 2) {\n                event.currentTarget.classList.add('js-hovered-link-top');\n            } else {\n                event.currentTarget.classList.add('js-hovered-link-bottom');\n            }\n\n            this.#onRelocateActivate();\n        });\n\n        linkRoot.addEventListener('mouseleave', event => {\n            if(!this.#selectedElement) return;\n            event.currentTarget.classList.remove('js-hovered-link-top');\n            event.currentTarget.classList.remove('js-hovered-link-bottom');\n        });\n\n        linkRoot.addEventListener('mousedown', event => {\n            event.stopPropagation();\n            this.#selectedElement = event.currentTarget;\n            this.#selectedType = 'link';\n            this.#onSelectForRelocation(linkData.id, 'link');\n        });\n\n        linkRoot.addEventListener('mouseup', event => {\n            const elementData = event.currentTarget.getAttribute('data-id').split('-');\n            let position = null;\n\n            const rootData = linkRoot.getBoundingClientRect();\n            if(event.clientY < rootData.y + rootData.height / 2) {\n                position = 'below';\n            } else {\n                position = 'above';\n            }\n\n            this.#onRelocateSuccess(parseInt(elementData[0]), elementData[1], position, !isPinned ? 'all' : 'pinned');\n\n            linkRoot.classList.remove('js-hovered-link-top');\n            linkRoot.classList.remove('js-hovered-link-bottom');\n            this.#pinnedLinksList.classList.remove('js-move');\n            this.#allLinksList.classList.remove('js-move');\n            if(this.#selectedElement) {\n                this.#selectedElement.classList.remove('js-selected-element');\n                this.#selectedElement = null;\n                this.#selectedType = '';\n            }\n        });\n\n        return linkRoot;\n    }\n\n    #createGroupDisplay(groupData, isPinned, location) {\n        const groupRoot = this.createElement('div', 'linkbook-browser-links-group');\n        const groupHeader = this.createElement('div', 'linkbook-browser-links-group__header');\n        const groupHeaderDetails = this.createElement('div', 'linkbook-browser-links-group__header-details');\n        const groupHeaderOptions = this.createElement('div', 'linkbook-browser-links-group__header-options');\n        const groupHeaderOptionAddLinkButton = this.createElement('button', 'linkbook-browser-links-group__header-option-icon', 'add-link-button');\n        const groupLinkList = this.createElement('div', 'linkbook-browser-links-group__links');\n\n        groupHeaderDetails.innerHTML = `\n            <svg class=\"linkbook-browser-links-group__header-icon\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n                <path d=\"M3.5 13.5H12.5C13.3273 13.5 14 12.8273 14 12V6C14 5.17266 13.3273 4.5 12.5 4.5H8.75C8.51328 4.5 8.29062 4.38984 8.15 4.2L7.7 3.6C7.41641 3.22266 6.97109 3 6.5 3H3.5C2.67266 3 2 3.67266 2 4.5V12C2 12.8273 2.67266 13.5 3.5 13.5Z\" fill=\"#E6E6E6\"/>\n            </svg>\n            <span class=\"linkbook-browser-links-group__header-title\">\n                ${groupData.name}\n            </span>\n        `;\n        groupHeaderOptionAddLinkButton.innerHTML = '<svg class=\"new-link-button__icon new-link-button__icon--secondary\" width=\"16\" height=\"13\" viewBox=\"0 0 16 13\"><path d=\"M14.07 6.7925C15.4825 5.38 15.4825 3.0925 14.07 1.68C12.82 0.430004 10.85 0.267504 9.4125 1.295L9.3725 1.3225C9.0125 1.58 8.93 2.08 9.1875 2.4375C9.445 2.795 9.945 2.88 10.3025 2.6225L10.3425 2.595C11.145 2.0225 12.2425 2.1125 12.9375 2.81C13.725 3.5975 13.725 4.8725 12.9375 5.66L10.1325 8.47C9.345 9.2575 8.07 9.2575 7.2825 8.47C6.585 7.7725 6.495 6.675 7.0675 5.875L7.095 5.835C7.3525 5.475 7.2675 4.975 6.91 4.72C6.5525 4.465 6.05001 4.5475 5.79501 4.905L5.7675 4.945C4.7375 6.38 4.90001 8.35 6.15001 9.6C7.56251 11.0125 9.85 11.0125 11.2625 9.6L14.07 6.7925ZM1.08 6.2075C-0.332495 7.62 -0.332495 9.9075 1.08 11.32C2.33 12.57 4.30001 12.7325 5.73751 11.705L5.77751 11.6775C6.13751 11.42 6.22001 10.92 5.96251 10.5625C5.70501 10.205 5.205 10.12 4.8475 10.3775L4.80751 10.405C4.00501 10.9775 2.9075 10.8875 2.2125 10.19C1.425 9.4 1.425 8.125 2.2125 7.3375L5.0175 4.53C5.805 3.7425 7.08 3.7425 7.8675 4.53C8.56501 5.2275 8.655 6.325 8.0825 7.1275L8.05501 7.1675C7.7975 7.5275 7.8825 8.0275 8.24 8.2825C8.5975 8.5375 9.10001 8.455 9.35501 8.0975L9.3825 8.0575C10.4125 6.62 10.25 4.65 9 3.4C7.5875 1.9875 5.30001 1.9875 3.88751 3.4L1.08 6.2075Z\" /></svg>';\n\n        groupRoot.setAttribute('data-id', `${groupData.id}-${groupData.type}-${isPinned ? 'pinned' : 'all' }`);\n        groupRoot.setAttribute('data-location', location);\n\n        groupRoot.append(groupHeader, groupLinkList);\n        groupHeader.append(groupHeaderDetails, groupHeaderOptions);\n        groupHeaderOptions.append(groupHeaderOptionAddLinkButton);\n\n        groupHeaderOptionAddLinkButton.addEventListener('click', _ => this.#onOpenLinkDataForm(groupData.id, (groupData.id !== 0 ? false : isPinned)));\n        groupRoot.addEventListener('contextmenu', event => {\n            event.preventDefault();\n            event.stopPropagation();\n            this.#onOpenOptionsMenu(groupRoot, groupData.type, groupData.id, isPinned, {pin: !isPinned, unpin: isPinned, edit: true, delete: true});\n        });\n\n        groupRoot.addEventListener('mousemove', event => {\n            if(event.buttons !== 1) return;\n            if(this.#selectedType === 'link') return;\n            const rootData = groupRoot.getBoundingClientRect();\n\n            groupRoot.classList.remove('js-hovered-group-top');\n            groupRoot.classList.remove('js-hovered-group-bottom');\n            if(event.clientY < rootData.y + rootData.height / 2) {\n                groupRoot.classList.add('js-hovered-group-top');\n            } else {\n                groupRoot.classList.add('js-hovered-group-bottom');\n            }\n\n            this.#onRelocateActivate();\n        });\n\n        groupHeader.addEventListener('mouseenter', event => {\n            if(!this.#selectedElement) return;\n            if(this.#selectedType !== 'link') return;\n            event.currentTarget.classList.add('js-hovered-group');\n        });\n\n        groupHeader.addEventListener('mouseleave', event => {\n            if(!this.#selectedElement) return;\n            event.currentTarget.classList.remove('js-hovered-group');\n        });\n\n        groupRoot.addEventListener('mouseleave', event => {\n            if(!this.#selectedElement) return;\n            groupRoot.classList.remove('js-hovered-group-top');\n            groupRoot.classList.remove('js-hovered-group-bottom');\n        });\n\n        groupRoot.addEventListener('mousedown', event => {\n            event.currentTarget.classList.add('js-selected-element');\n            this.#selectedElement = event.currentTarget;\n            this.#selectedType = 'group';\n            this.#onSelectForRelocation(groupData.id, 'group');\n        });\n\n        groupRoot.addEventListener('mouseup', event => {\n            const elementData = event.currentTarget.getAttribute('data-id').split('-');\n            let position;\n\n            const rootData = groupRoot.getBoundingClientRect();\n            if(event.clientY < rootData.y + rootData.height / 2) {\n                position = 'below';\n            } else {\n                position = 'above';\n            }\n\n            this.#onRelocateSuccess(parseInt(elementData[0]), elementData[1], position, !isPinned ? 'all' : 'pinned');\n\n            groupHeader.classList.remove('js-hovered-group');\n            groupRoot.classList.remove('js-hovered-group-top');\n            groupRoot.classList.remove('js-hovered-group-bottom');\n            this.#pinnedLinksList.classList.remove('js-move');\n            this.#allLinksList.classList.remove('js-move');\n            if(this.#selectedElement) {\n                this.#selectedElement.classList.remove('js-selected-element');\n                this.#selectedElement = null;\n                this.#selectedType = '';\n            }\n        });\n\n        return groupRoot;\n    }\n\n    editGroup(groupId, location) {\n        const groupRoot = this.getElement(`[data-id=\"${groupId}-group-${location}\"]`);       \n        const groupHeaderDetailsName = this.getElement('.linkbook-browser-links-group__header-title', groupRoot);\n        const groupHeaderOptions = this.getElement('.linkbook-browser-links-group__header-options', groupRoot);\n\n        while(groupHeaderOptions.firstChild) {\n            groupHeaderOptions.removeChild(groupHeaderOptions.lastChild);\n        }\n\n        const groupHeaderDetailsInput = this.createElement('input', 'linkbook-browser-links-group__header-input');\n        groupHeaderDetailsInput.setAttribute('type', 'text');\n        groupHeaderDetailsName.replaceWith(groupHeaderDetailsInput);\n\n        groupHeaderDetailsInput.addEventListener('keypress', event => {\n            if(event.key === 'Enter' && groupHeaderDetailsInput.value.length !== 0) {\n                this.#onGroupEditSave(groupId, groupHeaderDetailsInput.value);\n            }\n        });\n\n        groupHeaderDetailsInput.focus();\n    }\n\n    #createDisplayLinkDisplay(displayLinkData) {\n        const displayRoot = this.createElement('div', 'pinned-group-link');\n        const displayIcon = this.createElement('img', 'pinned-group-link__icon');\n        const displayName = this.createElement('p', 'pinned-group-link__name');\n\n        displayName.textContent = displayLinkData.name;\n        displayIcon.src = `https://www.google.com/s2/favicons?domain=${displayLinkData.link}&sz=64`;\n\n        displayRoot.append(displayIcon, displayName);\n\n        displayRoot.addEventListener('click', event => {\n            if(\n                event.target.classList.contains('options-button__icon') ||\n                event.target.classList.contains('button--small')\n            ) return;\n\n            const openInNewTab = !event.altKey;\n            this.#onOpenLink(displayLinkData.link, openInNewTab);\n        });\n\n        return displayRoot;\n    }\n\n    #createDisplayGroupDisplay(displayGroupData) {\n        const displayRoot = this.createElement('div', 'pinned-group');\n        const displayDetails = this.createElement('div', 'pinned-group__details');\n        const displayDetailsHeader = this.createElement('div', 'pinned-group__header');\n        const displayDetailsHeaderTitle = this.createElement('h3', 'pinned-group__title');\n        const displayDetailsLinks = this.createElement('div', 'pinned-group__links');\n\n        displayDetailsHeaderTitle.textContent = displayGroupData.name;\n\n        displayRoot.append(displayDetails);\n        displayDetails.append(displayDetailsHeader, displayDetailsLinks);\n        displayDetailsHeader.append(displayDetailsHeaderTitle);\n\n        return displayRoot;\n    }\n\n    displayAllLinksCategory(elements) {\n        while(this.#allLinksList.firstChild) {\n            this.#allLinksList.removeChild(this.#allLinksList.lastChild);\n        }\n\n        for(const element of elements) {\n            if(element.type === 'link') {\n                const linkDisplay = this.#createLinkDisplay(element, false, 'all');\n                this.#allLinksList.append(linkDisplay);\n            } else {\n                const groupDisplay = this.#createGroupDisplay(element, false, 'all');\n                this.#allLinksList.append(groupDisplay);\n\n                const groupList = this.getElement('.linkbook-browser-links-group__links', groupDisplay);\n                for(const child of element.children) {\n                    const linkDisplay = this.#createLinkDisplay(child, false, 'all-child');\n                    groupList.append(linkDisplay);\n                }\n            }\n        }\n    }\n\n    displayPinnedLinksCategory(elements) {\n        while(this.#pinnedLinksList.firstChild) {\n            this.#pinnedLinksList.removeChild(this.#pinnedLinksList.lastChild);\n        }\n\n        for(const element of elements) {\n            const groupDisplay = this.#createGroupDisplay(element, true, 'pinned');\n            this.#pinnedLinksList.append(groupDisplay);\n\n            const groupList = this.getElement('.linkbook-browser-links-group__links', groupDisplay);\n\n            for(const child of element.children) {\n                const linkDisplay = this.#createLinkDisplay(child, true, (element.id === 0 ? 'pinned' : 'pinned-child'));\n                groupList.append(linkDisplay);\n            }\n        }\n    }\n\n    displayPinnedLinksDisplay(elements) {\n        while(this.#pinnedLinksDisplay.firstChild) {\n            this.#pinnedLinksDisplay.removeChild(this.#pinnedLinksDisplay.lastChild);\n        }\n\n        for(const element of elements) {\n            const displayGroupDisplay = this.#createDisplayGroupDisplay(element);\n            this.#pinnedLinksDisplay.append(displayGroupDisplay);\n\n            const displayGroupList = this.getElement('.pinned-group__links', displayGroupDisplay);\n            for(const child of element.children) {\n                const displayLinkDisplay = this.#createDisplayLinkDisplay(child);\n                displayGroupList.append(displayLinkDisplay);\n            }\n        }\n    }\n\n    openLinkDataForm(editData) {\n        if(editData) {\n            this.getElement('[data-open-type=\"edit\"]', this.#linkDataForm).classList.remove('link-content-form__details-title--hidden');\n            this.#linkDataFormNameField.value = editData.name;\n            this.#linkDataFormLinkField.value = editData.link;\n            this.#linkDataForm.setAttribute('data-id', editData.id);\n        } else {\n            this.getElement('[data-open-type=\"create\"]', this.#linkDataForm).classList.remove('link-content-form__details-title--hidden');\n            this.#linkDataFormNameField.value = '';\n            this.#linkDataFormLinkField.value = '';\n        }\n\n        this.#linkDataForm.classList.remove('link-content-form--disabled');  \n    }\n\n    closeLinkDataForm() {\n        this.getElement('[data-open-type=\"create\"]', this.#linkDataForm).classList.add('link-content-form__details-title--hidden');\n        this.getElement('[data-open-type=\"edit\"]', this.#linkDataForm).classList.add('link-content-form__details-title--hidden');\n        this.#linkDataForm.classList.add('link-content-form--disabled');\n    }\n\n    openOptionsMenu(position, options) {\n        this.#optionsMenu.style.setProperty('--position-x', `${position.x}px`);\n        this.#optionsMenu.style.setProperty('--position-y', `${position.y}px`);\n\n        if(options.pin) this.#optionsMenuPin.classList.remove('link-options-menu__option--disabled');\n        else this.#optionsMenuPin.classList.add('link-options-menu__option--disabled');\n        if(options.unpin) this.#optionsMenuUnPin.classList.remove('link-options-menu__option--disabled');\n        else this.#optionsMenuUnPin.classList.add('link-options-menu__option--disabled');\n        if(options.edit) this.#optionsMenuEdit.classList.remove('link-options-menu__option--disabled');\n        else this.#optionsMenuEdit.classList.add('link-options-menu__option--disabled');\n        if(options.delete) this.#optionsMenuDelete.classList.remove('link-options-menu__option--disabled');\n        else this.#optionsMenuDelete.classList.add('link-options-menu__option--disabled');\n\n        this.#optionsMenu.classList.remove('link-options-menu--disabled');\n    }\n\n    closeOptionsMenu() {\n        this.#optionsMenu.classList.add('link-options-menu--disabled');\n    }\n\n    openAlertbox(prompt, yesHandler, noHandler) {\n        this.#alertbox.classList.remove('alertbox--hidden');\n        this.#alertboxPrompt.textContent = prompt;\n\n        this.#alertboxYesButton.onclick = _ => {\n            if(yesHandler) yesHandler();\n            this.closeAlertbox()\n        }\n        this.#alertboxNoButton.onclick = _ => {\n            if(noHandler) noHandler();\n            this.closeAlertbox();\n        };\n    }\n\n    closeAlertbox() {\n        this.#alertbox.classList.add('alertbox--hidden');\n        this.#alertboxPrompt.textContent = '';\n    }\n\n    createGlobalError(message) {\n        const rootElement = this.createElement('div', 'global-error-box');\n        const messageElement = this.createElement('p', 'glboal-error-box__message');\n\n        messageElement.textContent = message;\n        rootElement.append(messageElement);\n\n        this.#app.append(rootElement);\n        setTimeout(() => {\n            rootElement.classList.add('global-error-box--enabled');\n        }, 0);\n\n        setTimeout(() => {\n            rootElement.classList.remove('global-error-box--enabled');\n            setTimeout(() => {\n                rootElement.remove();\n            }, 1000);\n        }, 5 * 1000);\n    }\n}\n\nclass LinksController {\n    #model;\n    #view;\n\n    #newLinkData;\n    #moreOptionsState;\n\n    #relocationData;\n    #isRelocatable;\n\n    constructor(model, view) {\n        this.#model = model;\n        this.#view = view;\n\n        this.#model.bindLinkbookDataChanged(this.#onLinkbookDataChanged.bind(this));\n        this.#model.bindErrorHandle(this.#onHandleError.bind(this));\n\n        this.#view.bindOpenLink(this.#onOpenLink.bind(this));\n        this.#view.bindOpenLinkDataForm(this.#onOpenLinkDataForm.bind(this));\n        this.#view.bindCloseLinkDataForm(this.#onCloseLinkDataForm.bind(this));\n        this.#view.bindSaveLinkDataForm(this.#onSaveLinkDataForm.bind(this));\n        this.#view.bindCreateGroup(this.#onCreateGroup.bind(this));\n        this.#view.bindGroupEditSave(this.#onGroupEditSave.bind(this));\n\n        this.#view.bindOpenOptionsMenu(this.#onOpenOptionsMenu.bind(this));\n        this.#view.bindCloseOptionsMenu(this.#onCloseOptionsMenu.bind(this));\n        this.#view.bindOptionsMenuPin(this.#onOptionsMenuPin.bind(this));\n        this.#view.bindOptionsMenuUnpin(this.#onOptionsMenuUnpin.bind(this));\n        this.#view.bindOptionsMenuEdit(this.#onOptionsMenuEdit.bind(this));\n        this.#view.bindOptionsMenuDelete(this.#onOptionsMenuDelete.bind(this));\n\n        this.#view.bindSelectForRelocation(this.#onSelectForRelocation.bind(this));\n        this.#view.bindRelocationActivate(this.#onRelocateActivate.bind(this));\n        this.#view.bindRelocateSuccess(this.#onRelocateSuccess.bind(this));\n        this.#view.bindRelocateCancel(this.#onRelocateCancel.bind(this));\n\n        (async () => {\n            const groups = await this.#model.getGroups();\n            for(const group of groups) {\n                if(group.name.length !== 0) continue;\n                this.#model.deleteGroup(group.id);\n            }\n            const data = await this.#model.compileLinkbookData();\n            this.#onLinkbookDataChanged(data);\n        })();\n    }\n\n    #onLinkbookDataChanged(data) {\n        const linksDisplay = {\n            id: 0, \n            type: 'group', \n            name: 'Links', \n            isPinned: 'true', \n            children: [], \n            pinnedPosition: 0,\n            groupPosition: 0\n            \n        };\n\n        const restDisplay = [];\n        for(const element of data) {\n            if(element.type === 'link') {\n                if(!element.isPinned) continue;\n                linksDisplay.children.push(element);\n            } else {\n                if(element.isPinned) {\n                    restDisplay.push(element);\n                }\n\n                for(const child of element.children) {\n                    if(!child.isPinned) continue;\n                    linksDisplay.children.push(child);\n                }\n            }\n        }\n\n        const displayData = [];\n        if(linksDisplay.children.length !== 0) displayData.push(linksDisplay);\n        if(restDisplay.length !== 0) displayData.push(...restDisplay);\n\n        if(displayData.length !== 0) {\n            const groupLinkChildren = displayData[0].children;\n            if(groupLinkChildren.children !== 0) {\n                const quickNavLinks = new Map();\n                groupLinkChildren.forEach((link, index) => {\n                    quickNavLinks.set(index + 1, link.link);\n                });\n\n                document.addEventListener('keydown', event => {\n                    if(!event.ctrlKey) return;\n                    const quickNavElementId = parseInt(event.key);\n\n                    if(isNaN(quickNavElementId)) return;\n                    if(!quickNavLinks.has(quickNavElementId)) return;\n\n                    this.#onOpenLink(quickNavLinks.get(quickNavElementId), !event.altKey);\n                });\n            }\n        }\n\n        for(let i = 0; i < displayData.length - 1; i++) {\n            let min = displayData[i];\n            let minPos = i;\n\n            for(let j = i + 1; j < displayData.length; j++) {\n                if(displayData[j].pinnedPosition < min.pinnedPosition) {\n                    min = displayData[j];\n                    minPos = j;\n                }\n            }\n\n            if(minPos === i) continue;\n            displayData[minPos] = displayData[i];\n            displayData[i] = min;\n       }\n\n        if(displayData[0] && displayData[0].id === 0) {\n            for(let i = 0; i < displayData[0].children.length - 1; i++) {\n                let min = displayData[0].children[i];\n                let minPos = i;\n\n                for(let j = i + 1; j < displayData[0].children.length; j++) {\n                    if(displayData[0].children[j].pinnedPosition < min.pinnedPosition) {\n                        min = displayData[0].children[j];\n                        minPos = j;\n                    }\n                }\n\n                if(minPos === i) continue;\n                displayData[0].children[minPos] = displayData[0].children[i];\n                displayData[0].children[i] = min;\n            }\n        }\n\n        this.#view.displayAllLinksCategory(data);\n        this.#view.displayPinnedLinksCategory(displayData);\n        this.#view.displayPinnedLinksDisplay(displayData);\n    }\n\n    #onOpenLink(link, newTab) {\n        if(this.#isRelocatable) {\n            return;\n        }\n        const url = link.startsWith('http') ? link : `https://${link}`;\n\n        if(!newTab) {\n            location.assign(url);\n        } else {\n            open(url);\n        }\n\n    }\n    \n    #onOpenLinkDataForm(parentId, isPinned) {\n        this.#newLinkData = {parent: parentId, isPinned};\n        this.#view.openLinkDataForm(null);\n    }\n\n    #onCloseLinkDataForm() {\n        this.#newLinkData = null;\n        this.#view.closeLinkDataForm();\n    }\n\n    async #onSaveLinkDataForm(formData) {\n        if(!formData.id) {\n            const linkData = {...formData, ...this.#newLinkData};\n            const data = await this.#model.createLink(linkData.name, linkData.link, linkData.parent, linkData.isPinned)\n            if(!data) return;\n        } else {\n            const data = this.#model.editLinkNameAndLink(formData.id, formData.name, formData.link);\n            if(!data) return;\n        }\n\n        this.#onCloseLinkDataForm();\n    }\n\n    #onCreateGroup(isPinned) {\n        this.#model.createGroup(isPinned)\n            .then(group => {\n                if(!group) return;\n                this.#view.editGroup(group.id, isPinned ? 'pinned' : 'all')\n            });\n    }\n\n    #onGroupEditSave(groupId, groupName) {\n        this.#model.editGroupName(groupId, groupName);\n    }\n\n    #onOpenOptionsMenu(element, elementType, elementId, isElementPinned, options) {\n        const elementRect = element.getBoundingClientRect();\n        this.#moreOptionsState = {type: elementType, id: elementId, isPinned: isElementPinned};\n        this.#view.openOptionsMenu({x:  elementRect.right, y: elementRect.y + 30}, options);\n    }\n\n    #onCloseOptionsMenu() {\n        this.#view.closeOptionsMenu();\n    }\n\n    #onOptionsMenuPin() {\n        if(this.#moreOptionsState.type === 'link')\n            this.#model.editLinkPin(this.#moreOptionsState.id, true);\n        else\n            this.#model.editGroupPin(this.#moreOptionsState.id, true);\n    }\n\n    #onOptionsMenuUnpin() {\n        if(this.#moreOptionsState.type === 'link')\n            this.#model.editLinkPin(this.#moreOptionsState.id, false);\n        else\n            this.#model.editGroupPin(this.#moreOptionsState.id, false);\n    }\n\n    #onOptionsMenuEdit() {\n        if(this.#moreOptionsState.type === 'link') {\n            this.#model.getLink(this.#moreOptionsState.id)\n                .then(link => {\n                    // TODO: Handle empty link by displaying an error to the user\n                    if(!link) return;\n                    this.#view.openLinkDataForm(link);\n                });\n            \n        } else {\n            this.#view.editGroup(this.#moreOptionsState.id, this.#moreOptionsState.isPinned ? 'pinned' : 'all');\n        }\n    }\n\n    #onOptionsMenuDelete() {\n        if(this.#moreOptionsState.type === 'link') {\n            this.#model.deleteLink(this.#moreOptionsState.id);\n        } else {\n            this.#model.getGroupChildren(this.#moreOptionsState.id).then(children => {\n                if(children.length === 0) {\n                        this.#model.deleteGroup(this.#moreOptionsState.id);\n                } else {\n                    this.#view.openAlertbox(\n                        'This action will delete the group and all of it\\'s children. Continue?',\n                        _ => {\n                            for(const child of children) {\n                                this.#model.deleteLink(child.id);\n                            }\n                            this.#model.deleteGroup(this.#moreOptionsState.id);\n                        }\n                    );\n                }\n            })\n        }\n    }\n\n    #onSelectForRelocation(selectedElementId, selectedElementType) {\n        this.#relocationData = {selectedId: selectedElementId, selectedType: selectedElementType};\n    }\n\n    #onRelocateActivate() {\n        this.#isRelocatable = true;\n    }\n\n    #onRelocateCancel() {\n        if(!this.#relocationData) return;\n        this.#relocationData = null;\n        this.#isRelocatable = false;\n    }\n\n    #onRelocateSuccess(positionElementId, positionElementType, selectedElementLocation, relocationCategory) {\n        if(!this.#isRelocatable || !this.#relocationData || (this.#relocationData.selectedType === 'link' && this.#relocationData.newPositionId)) return;\n        this.#relocationData.newPositionId = positionElementId;\n        this.#relocationData.newPositionType = positionElementType;\n        this.#relocationData.newPositionDirection = selectedElementLocation;\n        this.#relocationData.relocationCategory = relocationCategory;\n\n        this.#model.relocate(this.#relocationData);\n    }\n\n    #onHandleError(error) {\n        if(error.constructor.name === 'UserError') {\n            this.#view.createGlobalError(error.message);\n        } else {\n            console.error(error.message, error.name, error.stack);\n        }\n    }\n}\n\nclass UserError extends Error {\n    constructor(error) {\n        if(typeof error === 'string') {\n            super(error);\n        } else {\n            super(error.message);\n            this.cause = error;\n        }\n\n        this.name = 'UserError';\n    }\n}\n\nclass SystemError extends Error {\n    constructor(error) {\n        if(typeof error === 'string') {\n            super(error);\n        } else {\n            super(error.message);\n            this.cause = error;\n        }\n\n        this.name = 'SystemError';\n    }\n}\n\nlet model;\nlet app;\naddEventListener('DOMContentLoaded', _ => {\n    model = new LinksModel()\n    app = new LinksController(model, new LinkbookView());\n})\n\n\n//# sourceURL=webpack://welcome/./src/webapp.js?");

/***/ }),

/***/ "./node_modules/idb/build/index.js":
/*!*****************************************!*\
  !*** ./node_modules/idb/build/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deleteDB\": () => (/* binding */ deleteDB),\n/* harmony export */   \"openDB\": () => (/* binding */ openDB),\n/* harmony export */   \"unwrap\": () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   \"wrap\": () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)\n/* harmony export */ });\n/* harmony import */ var _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap-idb-value.js */ \"./node_modules/idb/build/wrap-idb-value.js\");\n\n\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade((0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.result), event.oldVersion, event.newVersion, (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\n(0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.r)((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\n\n\n\n//# sourceURL=webpack://welcome/./node_modules/idb/build/index.js?");

/***/ }),

/***/ "./node_modules/idb/build/wrap-idb-value.js":
/*!**************************************************!*\
  !*** ./node_modules/idb/build/wrap-idb-value.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"a\": () => (/* binding */ reverseTransformCache),\n/* harmony export */   \"i\": () => (/* binding */ instanceOfAny),\n/* harmony export */   \"r\": () => (/* binding */ replaceTraps),\n/* harmony export */   \"u\": () => (/* binding */ unwrap),\n/* harmony export */   \"w\": () => (/* binding */ wrap)\n/* harmony export */ });\nconst instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n\n\n\n//# sourceURL=webpack://welcome/./node_modules/idb/build/wrap-idb-value.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/webapp.js");
/******/ 	
/******/ })()
;